[
  {
    "question": "Що таке JSX і чому він використовується в React?",
    "answers": [
      "JSX — це формат CSS у JavaScript",
      "JSX — це шаблонізатор для Node.js",
      "JSX — це формат даних для API",
      "JSX — це синтаксис, подібний до HTML, який дозволяє описувати UI компоненти прямо в JavaScript-коді"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Що буде результатом виконання коду?\n```jsx\nconst el = <div className='box' />;\nconsole.log(typeof el);\n```",
    "answers": ["'object'", "'undefined'", "'function'", "'string'"],
    "correctAnswerId": 0
  },
  {
    "question": "У чому відмінність між компонентами класу та функціональними компонентами в React?",
    "answers": [
      "Класові компоненти працюють тільки з Redux",
      "Функціональні компоненти не можуть використовувати props",
      "Класові компоненти використовуються лише на сервері",
      "Функціональні компоненти простіші та підтримують хуки; класи мають доступ до lifecycle методів і state через this"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Що таке useEffect() в React?",
    "answers": [
      "Функція для створення стилів",
      "Метод для оновлення DOM вручну",
      "Хук, який виконує побічні ефекти у функціональних компонентах (запити, таймери тощо)",
      "Метод класового компонента"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "Коли викликається useEffect з порожнім масивом залежностей `[]`?",
    "answers": [
      "Ніколи не викликається",
      "Перед кожним ререндером",
      "Після кожного оновлення компонента",
      "Лише після першого рендера (аналог componentDidMount)"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Що таке React Reconciliation?",
    "answers": [
      "Метод оптимізації webpack",
      "Спосіб злиття хуків",
      "Алгоритм, що визначає найменші зміни для оновлення реального DOM",
      "Алгоритм об'єднання стилів"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "Для чого використовується ключ `key` при рендерінгу списків у React?",
    "answers": [
      "Щоб приховати елемент",
      "Для ідентифікації елементів списку при оновленні UI",
      "Для валідації форми",
      "Для зберігання значення елемента"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що відбудеться при зміні state напряму в React?\n```js\nstate.count = 5;\n```",
    "answers": [
      "Компонент не буде перерендерено",
      "State автоматично синхронізується з DOM",
      "Відбудеться помилка",
      "Компонент буде перерендерено"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Як правильно оновити state у функціональному компоненті?",
    "answers": [
      "Використати setState() як у класових компонентах",
      "Змінити DOM вручну",
      "Присвоїти значення напряму",
      "Використати хук useState і викликати функцію оновлення"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Що повертає useState()?",
    "answers": [
      "Функцію для рендерингу",
      "Об'єкт з полем value",
      "Масив з поточним значенням і функцією для оновлення",
      "Нічого"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "Що таке props у React?",
    "answers": [
      "Вбудована змінна компонента",
      "Метод для зміни state",
      "Функція для підключення CSS",
      "Дані, що передаються з батьківського компонента до дочірнього"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Чому не можна змінювати props напряму всередині компонента?",
    "answers": [
      "Props зберігаються у кеші браузера",
      "Props не підтримуються у production-збірці",
      "Props не використовуються в функціональних компонентах",
      "Props — лише для читання, React очікує їх незмінність для правильного оновлення UI"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Що таке lifting state up в React?",
    "answers": [
      "Передача state з дочірніх компонентів в батьківський для спільного використання",
      "Оновлення стану через сервер",
      "Передача функцій як props",
      "Заміна хуків у компонентах"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Яка функція використовується для створення контексту в React?",
    "answers": [
      "initContext()",
      "createContext()",
      "useContext()",
      "createState()"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що робить React.memo()?",
    "answers": [
      "Мемоїзує компонент, щоб уникати зайвих перерендерів при незмінних props",
      "Зберігає значення змінної в локальне сховище",
      "Очищає state",
      "Створює копію компонента"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Що таке хук useCallback?",
    "answers": [
      "Повертає мемоїзовану версію колбек-функції, яка оновлюється лише при зміні залежностей",
      "Мемоїзує значення",
      "Повертає функцію виклику useEffect",
      "Це альтернатива useState"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Як уникнути нескінченних циклів при використанні useEffect?",
    "answers": [
      "Передавати масив залежностей як другий аргумент",
      "Оновлювати state напряму",
      "Використовувати return true всередині useEffect",
      "Використовувати setTimeout"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Що таке фрагменти (React.Fragment)?",
    "answers": [
      "Спеціальний тип компонента",
      "Спосіб групування елементів без додаткового вузла в DOM",
      "Метод для зміни state",
      "Компонент для переробки HTML"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що таке Portals в React?",
    "answers": [
      "Компоненти для сторінок",
      "Механізм для рендерингу елементів за межами DOM-ієрархії батьківського компонента",
      "Фреймворк для анімації",
      "Застарілий спосіб стилізації"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що таке React.lazy і для чого він потрібен?",
    "answers": [
      "Для управління контекстом",
      "Для відкладеного виклику setState",
      "Для створення резервного UI",
      "Для динамічного імпорту компонентів з розбиттям коду (code-splitting)"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Що таке Suspense у React?",
    "answers": [
      "Компонент для анімацій",
      "Метод керування state",
      "Хук для оптимізації",
      "Компонент, що дозволяє відображати запасний контент під час завантаження дочірніх компонентів"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Що таке Custom Hooks?",
    "answers": [
      "Функції, що працюють лише з Redux",
      "Методи для роботи з формами",
      "Компоненти з розширеним API",
      "Функції, які починаються з 'use' і дозволяють повторно використовувати логіку між компонентами"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Як React визначає, що компонент потрібно перерендерити?",
    "answers": [
      "Після кожного кліку",
      "При зміні props або state",
      "Тільки при зміні props",
      "Кожні 100 мс"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що таке useRef і для чого він використовується?",
    "answers": [
      "Функція зміни стилів",
      "Метод для створення state",
      "Хук для створення посилання на DOM-елемент або збереження значення між рендерами",
      "Хук для HTTP-запитів"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "Що таке forwardRef у React?",
    "answers": [
      "Компонент для створення класів",
      "Метод для оновлення useRef",
      "Метод для оптимізації props",
      "Функція для передачі ref з батьківського компонента в дочірній"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Що таке useContext у React?",
    "answers": [
      "Метод для відкладеного завантаження",
      "Хук для створення state",
      "Це хук, що дозволяє отримувати доступ до контексту, створеного через createContext",
      "Функція для створення нового контексту"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "Що таке компонент з керованою формою (controlled component)?",
    "answers": [
      "Компонент, у якому значення форми зберігається у state React",
      "Форма, що завантажується з сервера",
      "Форма, яка керується браузером",
      "Компонент з великою кількістю стилів"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Яка роль useReducer в React?",
    "answers": [
      "Метод для мемоїзації функцій",
      "Альтернатива useState для складної логіки стану з чіткими правилами оновлення",
      "Функція для маніпуляції DOM",
      "Хук для створення контексту"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що буде результатом цього коду?\n```jsx\nconst [count, setCount] = useState(0);\nsetCount(count + 1);\nsetCount(count + 1);\nconsole.log(count);\n```",
    "answers": ["2", "1", "0", "Помилка"],
    "correctAnswerId": 2
  },
  {
    "question": "Що таке StrictMode у React?",
    "answers": [
      "Хук для захисту від помилок",
      "Компонент, що допомагає виявляти потенційні проблеми в додатку",
      "Режим для створення production-збірки",
      "Метод логування стану"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що робить хук useMemo?",
    "answers": [
      "Зберігає DOM-посилання",
      "Повертає мемоїзовану функцію",
      "Виконує побічні ефекти",
      "Мемоїзує обчислене значення, щоб уникнути непотрібних обчислень при ререндері"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Що відбудеться, якщо в компоненті не вказати key при рендерінгу списку?",
    "answers": [
      "React може неправильно оновлювати елементи, що вплине на продуктивність",
      "Компонент не буде показано",
      "Стан буде втрачено",
      "Сторінка оновиться повністю"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Що таке hydration у React?",
    "answers": [
      "Оновлення контексту",
      "Процес синхронізації клієнтського React з HTML, згенерованим на сервері",
      "Додавання анімацій",
      "Передача пропсів у компонент"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що таке Error Boundary в React?",
    "answers": [
      "Функція логування",
      "Компонент, який ловить JavaScript-помилки в дочірніх компонентах і відображає запасний UI",
      "Метод useEffect з try/catch",
      "Сторінка з помилкою 404"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "У чому різниця між useEffect та useLayoutEffect?",
    "answers": [
      "useLayoutEffect виконується синхронно після всіх змін DOM, useEffect — асинхронно після рендеру",
      "useEffect працює тільки з API",
      "useLayoutEffect використовується для стилів",
      "useEffect є класовим методом"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Що таке suspense fallback?",
    "answers": [
      "Застаріла опція React 16",
      "Метод обробки помилок у Redux",
      "Компонент, який відображається під час завантаження lazy-компонента",
      "Функція зміни стану"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "Яке призначення `defaultValue` у формі React?",
    "answers": [
      "Обов'язково вказується для всіх input",
      "Встановлює глобальне значення для всіх полів",
      "Задає початкове значення для неконтрольованого компонента",
      "Призначене лише для select"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "Що таке useId() в React 18?",
    "answers": [
      "Хук для генерації унікальних і стабільних ідентифікаторів",
      "Метод фільтрації списків",
      "API для збереження сесій",
      "Функція для авторизації користувачів"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Як працює ключ `key` в списку React?",
    "answers": [
      "Він блокує ререндер",
      "Він допомагає React швидко знаходити, які елементи змінилися, видалилися або додалися",
      "Він визначає, який input виділений",
      "Це необхідна умова для SSR"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що таке Context API у React?",
    "answers": [
      "Метод useEffect з пропсами",
      "Спосіб передавати дані через дерево компонентів без проп drilling",
      "Хук для мемоїзації функцій",
      "Фреймворк для стилізації"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що таке проп drilling у React?",
    "answers": [
      "Патерн для lazy loading",
      "Коли props передаються через багато рівнів компонентів, навіть якщо проміжним компонентам вони не потрібні",
      "Передача props через context",
      "Метод відладки state"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що таке React Hook Form?",
    "answers": [
      "Метод логування даних форми",
      "Компонент для стилізації форм",
      "Бібліотека для керування станом форм з валідацією",
      "Хук для підключення до API"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "У чому перевага використання useTransition в React 18?",
    "answers": [
      "Для оновлення DOM напряму",
      "Для відкладених оновлень UI без блокування взаємодії",
      "Для керування фокусом",
      "Для створення анімацій"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що таке Server Components у React?",
    "answers": [
      "Компоненти, що містять CSS-модулі",
      "Сторінки з SSR у Next.js",
      "Застарілий API React",
      "Компоненти, що рендеряться повністю на сервері без надсилання JS в клієнт"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Чим відрізняється useImperativeHandle від useRef?",
    "answers": [
      "useRef призначений тільки для класових компонентів",
      "useImperativeHandle дозволяє обмежити доступ до певних методів через ref",
      "useImperativeHandle створює state",
      "Вони працюють однаково"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що таке React Profiler?",
    "answers": [
      "Метод логування помилок",
      "Інструмент для вимірювання продуктивності рендерів компонентів",
      "Бібліотека для тестування",
      "Компонент для стилізації"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Яка роль key в масиві компонентів?",
    "answers": [
      "Ідентифікація елементів для ефективного оновлення Virtual DOM",
      "Зберігання стану у localStorage",
      "Прив’язка до форми",
      "Заміна props"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Що таке fallback в Suspense?",
    "answers": [
      "Метод обробки помилок у формі",
      "UI, що показується під час завантаження lazy-компонентів",
      "Функція виклику setState",
      "Сторінка з повідомленням '404 Not Found'"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що таке useDeferredValue?",
    "answers": [
      "Хук, який дозволяє відкладати оновлення значень, щоб уникнути фризів",
      "Альтернатива useState",
      "Функція, що повертає memoized callback",
      "Метод для очищення кешу"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Що таке useSyncExternalStore в React 18?",
    "answers": [
      "Сервіс для завантаження зображень",
      "Хук для підключення до зовнішніх джерел стану з підтримкою синхронізації",
      "Хук для створення контексту",
      "Метод стилізації зовнішніх компонентів"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Чим useEffect відрізняється від componentDidMount?",
    "answers": [
      "componentDidMount викликається до render",
      "useEffect викликається після рендера і може виконуватись багато разів; componentDidMount — один раз після монтування",
      "componentDidMount працює в функціональних компонентах",
      "useEffect працює лише з класами"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що таке `dangerouslySetInnerHTML`?",
    "answers": [
      "Атрибут, що дозволяє вставити HTML у компонент, обминаючи JSX-екранування",
      "Метод додавання event listeners",
      "Функція захисту від XSS",
      "Метод для очищення DOM"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Як працює useLayoutEffect?",
    "answers": [
      "Аналог componentDidUpdate",
      "Асинхронно після рендеру",
      "Виконується синхронно після DOM-мутацій, перед тим як браузер намалює сторінку",
      "Для затримки анімацій"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "Що таке useInsertionEffect?",
    "answers": [
      "Функція очищення useEffect",
      "Альтернатива useMemo",
      "Хук для вставки стилів перед рендерингом",
      "Компонент валідації форм"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "Який хук використовують для керування фокусом?",
    "answers": ["useMemo", "useRef", "useState", "useFocus"],
    "correctAnswerId": 1
  },
  {
    "question": "Що таке forwardRef?",
    "answers": [
      "Метод створення DOM",
      "Хук валідації полів",
      "Функція, яка дозволяє передавати ref у дочірній компонент",
      "Бібліотека для роутингу"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "Яка бібліотека найчастіше використовується з React для роутингу?",
    "answers": ["redux-toolkit", "react-router-dom", "formik", "react-dom"],
    "correctAnswerId": 1
  },
  {
    "question": "Як React працює з подіями?",
    "answers": [
      "Події передаються через Redux",
      "Використовує власну систему SyntheticEvent, яка працює кросбраузерно",
      "Використовує WebSocket",
      "Працює напряму з native event"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що таке Controlled vs Uncontrolled компонент?",
    "answers": [
      "Uncontrolled працюють лише з Redux",
      "У Controlled стан зберігається у React, у Uncontrolled — в DOM через ref",
      "Controlled зберігає стан у браузері",
      "Uncontrolled компоненти не підтримуються"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що таке React Fiber?",
    "answers": [
      "Фреймворк для серверного рендерингу",
      "Альтернатива useEffect",
      "Нова архітектура рендерингу в React, яка дозволяє планування та розбиття рендеру",
      "Бібліотека для стилів"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "Чим useId відрізняється від useRef().current?",
    "answers": [
      "useRef працює тільки з form",
      "useId генерує унікальні ID, useRef — зберігає стабільне значення між рендерами",
      "Немає різниці",
      "useId створює новий DOM"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що таке memoization у React?",
    "answers": [
      "Компонент для стилізації",
      "Метод для оновлення state",
      "Інструмент для логування",
      "Оптимізація, що зберігає результат функції, щоб уникнути повторних обчислень"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Що робить useImperativeHandle?",
    "answers": [
      "Керує асинхронними запитами",
      "Створює ефект як useEffect",
      "Передає пропси дочірньому компоненту",
      "Дозволяє кастомізувати публічні методи, доступні через ref"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Що таке lazy loading компонентів у React?",
    "answers": [
      "Завантаження компонентів лише тоді, коли вони потрібні (динамічний імпорт)",
      "Кешування локального стану",
      "Пререндер сторінки",
      "Асинхронне оновлення state"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Яка роль context у React?",
    "answers": [
      "Використовується для валідації",
      "Працює лише з useRef",
      "Керує маршрутизацією",
      "Надає спосіб передавати дані через дерево компонентів без props"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Коли використовується cleanup функція в useEffect?",
    "answers": [
      "Щоб прибрати стилі",
      "Викликається при зміні state",
      "Для очищення побічних ефектів перед наступним викликом або при демонтажі",
      "Щоб очистити localStorage"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "Що таке PureComponent у React?",
    "answers": [
      "Компонент без DOM",
      "Компонент, який не використовує state",
      "Класовий компонент, що виконує поверхневе порівняння props і state",
      "Альтернатива useEffect"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "Що таке Virtual DOM?",
    "answers": [
      "Інструмент розробника",
      "Копія реального DOM у пам’яті, яку React використовує для оптимізації оновлень",
      "Функція для перевірки помилок",
      "DOM для мобільних пристроїв"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що таке prop-types?",
    "answers": [
      "Бібліотека для перевірки типів props у компонентах React",
      "Бібліотека для логування пропсів",
      "Метод стилізації компонентів",
      "Хук валідації форм"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Що таке Fragment у React?",
    "answers": [
      "CSS-клас",
      "Метод зміни стилів",
      "Назва нового хуку",
      "Контейнер без додаткового DOM-елемента"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Що відбудеться, якщо змінити state напряму?",
    "answers": [
      "React покаже помилку",
      "Рендер буде повторено двічі",
      "Стан буде оновлений одразу",
      "Компонент не буде перерендерено"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Чи можна використовувати кілька useEffect у компоненті?",
    "answers": [
      "Так, скільки завгодно",
      "Ні, тільки один",
      "Лише в класових компонентах",
      "Лише з useState"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Яка перевага хуків перед класами?",
    "answers": [
      "Мають кращу продуктивність",
      "Не потребують ререндеру",
      "Простіший синтаксис і можливість повторного використання логіки",
      "Вони автоматично кешуються"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "Що таке HOC (Higher-Order Component) у React?",
    "answers": [
      "Компонент, що містить хедер",
      "Хук для рендерінгу сторінок",
      "Функція, яка приймає компонент і повертає новий компонент з додатковою логікою",
      "Компонент з високим пріоритетом рендеру"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "Що таке Tree Shaking і як це стосується React?",
    "answers": [
      "Фреймворк для SSR",
      "Метод синхронізації state",
      "Процес видалення не використаного коду під час бандлінгу",
      "Процес ререндеру дочірніх компонентів"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "Як React визначає, що треба оновити компонент?",
    "answers": [
      "Після кожного кліку на DOM",
      "Зміни в URL",
      "Фонові HTTP-запити",
      "Зміни в props або state"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Що таке StrictMode і що він робить у React?",
    "answers": [
      "Обмеження розміру компонентів",
      "Заміна useEffect",
      "Увімкнення strict-режиму JavaScript",
      "Додаткові перевірки на помилки під час розробки"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Що робить метод ReactDOM.createPortal()?",
    "answers": [
      "Створює нову сторінку",
      "Робить snapshot компонента",
      "Створює контекст",
      "Рендерить компонент у DOM-елемент поза DOM-ієрархією батьків"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Що таке useCallback і навіщо він потрібен?",
    "answers": [
      "Для мемоїзації функції та запобігання зайвим ререндерам дочірніх компонентів",
      "Для асинхронного виклику функцій",
      "Для створення анімацій",
      "Для форматування значень"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Що таке props.children у React?",
    "answers": [
      "Метод передачі функцій",
      "Дочірні елементи, передані всередину компонента",
      "Підкомпоненти ReactDOM",
      "Альтернатива useEffect"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що таке Code Splitting у React?",
    "answers": [
      "Метод оптимізації props",
      "Механізм очищення state",
      "Процес створення бекапу коду",
      "Розділення коду на частини, щоб зменшити початковий об’єм завантаження"
    ],
    "correctAnswerId": 3
  },
  {
    "question": "Як правильно додати обробник подій до елемента в React?",
    "answers": [
      "onClick={() => handleClick()}",
      "onclick='handleClick()'",
      "click=handleClick",
      "addEventListener('click', handleClick)"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Що таке lazy() у React?",
    "answers": [
      "Фреймворк для маршрутизації",
      "Функція для динамічного імпорту компонентів",
      "Метод запізнілого рендерингу DOM",
      "Хук кешування"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Чому важливо уникати анонімних функцій у JSX?",
    "answers": [
      "Вони створюють нову функцію при кожному рендері, що може викликати зайві оновлення",
      "Вони заблоковані в браузерах",
      "Вони працюють лише в strict mode",
      "Вони викликаються автоматично"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Що таке useEffect cleanup function?",
    "answers": [
      "Функція для оновлення props",
      "Функція, яка виконується перед наступним викликом useEffect або при демонтажі",
      "Функція для очистки localStorage",
      "Альтернатива componentDidUnmount"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що таке shallow rendering у тестуванні React-компонентів?",
    "answers": [
      "Повне рендеринг-древо",
      "Рендер лише одного рівня компонента без дочірніх",
      "Рендер HTML у DOM",
      "Тестування API-запитів"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Як React визначає, що два компоненти однакові в Virtual DOM?",
    "answers": [
      "За порядком оголошення",
      "За іменем функції",
      "За типом компонента та значенням props",
      "За розміром JSX"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "Як передати значення з дочірнього компонента в батьківський?",
    "answers": [
      "Через callback-функцію, передану як props",
      "Це неможливо",
      "Через context тільки",
      "За допомогою useState"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Що таке React Concurrent Mode?",
    "answers": [
      "Набір нових можливостей для плавного рендерингу з підтримкою пріоритетів",
      "Інструмент для оптимізації білду",
      "Режим SSR",
      "Альтернатива StrictMode"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Що таке useTransition у React?",
    "answers": [
      "Метод переключення між компонентами",
      "Інструмент для валідації форм",
      "Хук, що дозволяє відкласти оновлення з низьким пріоритетом для покращення UX",
      "Функція рендеру анімацій"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "Що таке React DevTools?",
    "answers": [
      "Інструмент браузера для налагодження та профілювання React-компонентів",
      "Консольний інтерфейс для React",
      "Бібліотека UI-компонентів",
      "Альтернатива Redux"
    ],
    "correctAnswerId": 0
  },
  {
    "question": "Коли краще використовувати useReducer замість useState?",
    "answers": [
      "Для глобального state",
      "Коли логіка оновлення стану складна або залежить від попереднього стану",
      "Коли використовуєш CSS-in-JS",
      "Для простих форм"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Що таке Suspense boundaries?",
    "answers": [
      "Обгортка для контексту",
      "Обмеження використання useEffect",
      "Компоненти, що огортають асинхронні дочірні компоненти і показують fallback під час завантаження",
      "Сторінка помилок"
    ],
    "correctAnswerId": 2
  },
  {
    "question": "Який підхід найкращий для унікального id при SSR та клієнтському рендері?",
    "answers": ["useRef + uuid", "Math.random", "crypto.randomUUID()", "useId"],
    "correctAnswerId": 3
  },
  {
    "question": "Що таке React Portal?",
    "answers": [
      "Сторінка для лінкування компонентів",
      "Спосіб рендерити елемент поза DOM-ієрархією батьківського компонента",
      "Контейнер для SSR",
      "Сторінка аутентифікації"
    ],
    "correctAnswerId": 1
  },
  {
    "question": "Чи можна викликати хук умовно?",
    "answers": [
      "Так, якщо залежить від state",
      "Так, в if/else можна",
      "Ні, хуки мають викликатися завжди в одному порядку",
      "Так, у return() JSX"
    ],
    "correctAnswerId": 2
  }
]
